#!/usr/bin/env python3
"""
Sync Agents Script (Smart Compiler Edition)
Generated by Agentic Project Template

Acts as a deterministic compiler for AI configurations.
Source of Truth: ai/AGENTS.md + ai/rules/*.md
Outputs:
  - GitHub Copilot (.github/copilot-instructions.md)
  - Cursor (.cursor/rules/*.mdc)
  - Cline (.clinerules)
  - Windsurf (.windsurf/rules/*.md)

Usage:
  python scripts/sync_agents.py          # Syncs files
  python scripts/sync_agents.py --check  # Checks for drift (CI mode)
"""

import os
import glob
import sys
import argparse
import textwrap

# --- Configuration ---
ROOT_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
AI_DIR = os.path.join(ROOT_DIR, "ai")
RULES_DIR = os.path.join(AI_DIR, "rules")
AGENTS_FILE = os.path.join(AI_DIR, "AGENTS.md")

# Output Paths
GITHUB_DIR = os.path.join(ROOT_DIR, ".github")
CURSOR_RULES_DIR = os.path.join(ROOT_DIR, ".cursor", "rules")
WINDSURF_RULES_DIR = os.path.join(ROOT_DIR, ".windsurf", "rules")
CLINE_FILE = os.path.join(ROOT_DIR, ".clinerules")
COPILOT_FILE = os.path.join(GITHUB_DIR, "copilot-instructions.md")

# Limits
COPILOT_CHAR_LIMIT = 18000


def read_file(path):
    if not os.path.exists(path):
        return ""
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


def write_file(path, content, dry_run=False):
    """Writes file and returns True if content changed"""
    os.makedirs(os.path.dirname(path), exist_ok=True)

    current_content = ""
    if os.path.exists(path):
        current_content = read_file(path)

    if current_content == content:
        return False  # No change

    if not dry_run:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"‚úì Generated: {os.path.relpath(path, ROOT_DIR)}")
    else:
        print(f"‚ö† Drift detected: {os.path.relpath(path, ROOT_DIR)}")

    return True


def get_rules():
    """Reads all markdown files from ai/rules/"""
    rules = []
    if os.path.exists(RULES_DIR):
        for file in glob.glob(os.path.join(RULES_DIR, "*.md")):
            name = os.path.splitext(os.path.basename(file))[0]
            content = read_file(file)
            rules.append({"name": name, "content": content})
    return rules


def compile_copilot(agents_content, rules, check_drift=False):
    """
    Adapter for Copilot:
    - Filters out tool-specific sections
    - Concatenates rules
    - Truncates to limit
    """
    # 1. Start with Constitution
    full_text = f"# Repository Instructions for GitHub Copilot\n\n{agents_content}\n"

    # 2. Append Rules
    for rule in rules:
        full_text += f"\n## Rule: {rule['name']}\n{rule['content']}"

    # 3. Smart Filtering (Remove specific headers)
    filtered_lines = []
    drop_section = False
    drop_headers = ["## Cline", "## Windsurf", "## Cursor", "## Tooling", "# Tooling"]

    for line in full_text.splitlines():
        if any(line.startswith(h) for h in drop_headers):
            drop_section = True
        elif line.startswith("#") and not any(line.startswith(h) for h in drop_headers):
            drop_section = False

        if not drop_section:
            filtered_lines.append(line)

    final_text = "\n".join(filtered_lines)

    # 4. Truncate
    if len(final_text) > COPILOT_CHAR_LIMIT:
        final_text = (
            final_text[:COPILOT_CHAR_LIMIT]
            + "\n\n<!-- TRUNCATED: Content exceeded limit -->"
        )

    return write_file(COPILOT_FILE, final_text, dry_run=check_drift)


def compile_cursor(agents_content, rules, check_drift=False):
    drift = False

    # Constitution
    agents_mdc = textwrap.dedent(f"""\
        ---
        description: "Core Agent Constitution & Workflow"
        globs: ["**/*"]
        alwaysApply: true
        ---
        {agents_content}
    """)
    if write_file(
        os.path.join(CURSOR_RULES_DIR, "00-constitution.mdc"),
        agents_mdc,
        dry_run=check_drift,
    ):
        drift = True

    # Rules
    for rule in rules:
        rule_mdc = textwrap.dedent(f"""\
            ---
            description: "Rule: {rule["name"]}"
            globs: ["**/*"]
            alwaysApply: false
            ---
            {rule["content"]}
        """)
        if write_file(
            os.path.join(CURSOR_RULES_DIR, f"{rule['name']}.mdc"), rule_mdc, check_drift
        ):
            drift = True

    return drift


def compile_cline(agents_content, rules, check_drift=False):
    content = [f"# Cline Rules\n\n{agents_content}\n"]
    for rule in rules:
        content.append(f"\n## {rule['name']}\n{rule['content']}")

    return write_file(CLINE_FILE, "\n".join(content), dry_run=check_drift)


def compile_windsurf(agents_content, rules, check_drift=False):
    drift = False

    # Constitution
    if write_file(
        os.path.join(WINDSURF_RULES_DIR, "global.md"),
        agents_content,
        dry_run=check_drift,
    ):
        drift = True

    # Concatenate rules into one file for now (simplest for windsurf discovery)
    rules_content = "# Project Rules\n\n"
    for rule in rules:
        rules_content += f"## {rule['name']}\n{rule['content']}\n\n"

    if write_file(
        os.path.join(WINDSURF_RULES_DIR, "rules.md"), rules_content, dry_run=check_drift
    ):
        drift = True

    return drift


def main():
    parser = argparse.ArgumentParser(description="Compile AI Agent Configurations")
    parser.add_argument(
        "--check", action="store_true", help="Check for drift (fail if changes needed)"
    )
    args = parser.parse_args()

    print(f"üîÑ Syncing AI Agents from {os.path.relpath(AI_DIR, ROOT_DIR)}...")

    if not os.path.exists(AGENTS_FILE):
        print(f"‚ùå Error: Constitution not found at {AGENTS_FILE}")
        sys.exit(1)

    agents_content = read_file(AGENTS_FILE)
    rules = get_rules()

    drift_detected = False
    drift_detected |= compile_copilot(agents_content, rules, args.check)
    drift_detected |= compile_cursor(agents_content, rules, args.check)
    drift_detected |= compile_cline(agents_content, rules, args.check)
    drift_detected |= compile_windsurf(agents_content, rules, args.check)

    if args.check and drift_detected:
        print("\n‚ùå DRIFT DETECTED: Configuration files are out of sync with SSoT.")
        print("Run 'python scripts/sync_agents.py' to fix.")
        sys.exit(1)

    if args.check:
        print("‚úÖ No drift detected. All systems nominal.")
    else:
        print("‚ú® Sync Complete!")


if __name__ == "__main__":
    main()
